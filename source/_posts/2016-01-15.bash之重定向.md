layout: post
title: bash之重定向
comments: true
categries: []
tags: []
date: 2016-01-15 10:43:49
updated: 2016-01-15 10:43:49
toc:
original:
permallink:
fancybox:
---

------

linux 有三个系统级别的文件描述符：0（标准输入）,1（标准输出）,2（标准错误）。可以理解为linux跟踪打开文件，而分配的一个数字，这个数字有点类似c语言操作文件时候的句柄，通过句柄就可以实现文件的读写操作。 用户可以自定义文件描述符范围是：3-num,这个最大数字，跟用户的：ulimit –n 定义数字有关系，不能超过最大值。
一条shell命令执行，都会继承父进程的文件描述符。因此所有运行shell命令都会默认3个文件描述符。

-------------------

<!--more-->

#### 输出重定向

```
command-line1 [1-n] > file或文件操作符或设备
```
上面命令意思是：将一条命令执行结果（标准输出，或者错误输出，本来都要打印到屏幕上面的）  重定向其它输出设备（文件，打开文件操作符，或打印机等等）1,2分别是标准输出，错误输出。有几点需要注意(有几点是重复的)：

```

1. &[n] 代表是已经存在的文件描述符，&1 代表输出 &2代表错误输出 &-代表关闭与它绑定的描述符
2. /dev/null 这个设备，是linux中黑洞设备，什么信息输出到这个设备，都会吃掉
3. 2>&1 重定向stderr到stdout. 将错误消息的输出, 发送到与标准输出所指向的地方.
4.  i>&j 重定向文件描述符i到j. 向i文件的所有输出都发送到j.
5.  `>&j` 默认的, 重定向文件描述符1(stdout)到j. 所有传递到stdout的输出都送到j中去
6.  &> 等如 2>&1
```

--------------------

#### 输入重定向

```
command-line < file或文件描述符&设备  
```
将stdin重定向到file，这样本来需要从键盘获取输入的命令会转移到文件读取内容。

```
命令 << EOF
  内容段
EOF
```
将“内容段”整个作为命令的输入
两个 EOF 之间的内容(Here Document Content 部分) 传递给cmd 作为输入参数。注意：
* 结尾的EOF需要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。
* 开始的EOF前后的空格会被忽略掉。

-----------------

####exec绑定重定向
